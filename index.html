<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Animation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #sky { display: block; }
    </style>
</head>
<body>
    <canvas id="sky"></canvas>
    <script>
        // Get canvas and context
        let c = document.getElementById('sky');
        let ctx = c.getContext('2d');
        
        // Set canvas size to window dimensions
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        
        // Array to store star objects
        let objects = [];
        for (let i = 0; i < 50; i++) {
            objects.push({
                x: Math.random() * c.width,
                y: Math.random() * c.height,
                speed: Math.random() * 0.15 + 0.05, // Very slow speed: 0.05 to 0.2 for barely perceived movement
                color: 'white'
            });
        }
        
        let t = 0; // Frame counter
        let planeActive = true; // Track if plane is visible
        
        // Plane properties for depth simulation
        let planeZ = 100; // Simulated depth (starts far, decreases to approach)
        let planeSize = 3; // Initial size
        
        function draw() {
            // Clear canvas with black background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, c.width, c.height);
            
            // Draw and update stars
            for (let o of objects) {
                ctx.fillStyle = o.color;
                ctx.fillRect(o.x, o.y, 1, 1); // 1x1 pixel stars
                o.x += o.speed; // Move right slowly
                if (o.x > c.width) o.x = 0; // Wrap around to left
            }
            
            // Plane movement (only if active)
            if (planeActive) {
                // Simulate approaching: decrease Z (depth), increase size
                if (t < 200) {
                    planeZ -= 0.4; // Approach speed
                    planeSize = 3 + (100 - planeZ) * 0.1; // Grow size as it approaches
                }
                
                let px = c.width / 2 + Math.sin(t * 0.02) * 200; // Zigzag horizontally
                let py = c.height / 2 - t * 0.5; // Steady upward motion
                
                // After 200 frames, accelerate right and stop approaching
                if (t > 200) {
                    px += (t - 200) * 3; // Faster exit right
                }
                
                // Draw plane if still on screen
                if (px < c.width && py > 0 && planeZ > 0) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(px - planeSize / 2, py - planeSize / 2, planeSize, planeSize); // Centered, growing square
                } else {
                    planeActive = false; // Stop drawing once off-screen or too close
                }
            }
            
            // Top-down view window (mini-map) in lower right
            let miniSize = 150; // Size of mini window
            let miniX = c.width - miniSize - 20; // Position: 20px from right
            let miniY = c.height - miniSize - 20; // Position: 20px from bottom
            
            // Draw mini window background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent black
            ctx.fillRect(miniX, miniY, miniSize, miniSize);
            
            // Draw borders and N/E/S/W labels
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(miniX, miniY, miniSize, miniSize);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('N', miniX + miniSize / 2 - 5, miniY + 15); // North (top)
            ctx.fillText('S', miniX + miniSize / 2 - 5, miniY + miniSize - 5); // South (bottom)
            ctx.fillText('W', miniX + 5, miniY + miniSize / 2 + 5); // West (left)
            ctx.fillText('E', miniX + miniSize - 15, miniY + miniSize / 2 + 5); // East (right)
            
            // Draw crosshairs for center (viewer position)
            ctx.beginPath();
            ctx.moveTo(miniX + miniSize / 2, miniY);
            ctx.lineTo(miniX + miniSize / 2, miniY + miniSize);
            ctx.moveTo(miniX, miniY + miniSize / 2);
            ctx.lineTo(miniX + miniSize, miniY + miniSize / 2);
            ctx.stroke();
            
            // Plot plane position in top-down view (relative to center)
            if (planeActive && planeZ > 0) {
                // Map plane position: X (east-west), Y (north-south inverted), Z scales distance
                let miniPx = miniSize / 2 + (px - c.width / 2) / 10; // Scaled horizontal (right = east)
                let miniPy = miniSize / 2 - (py - c.height / 2) / 10 + planeZ / 10; // Scaled vertical (up = north), approach moves it north
                ctx.fillStyle = 'red';
                ctx.fillRect(miniX + miniPx - 2, miniY + miniPy - 2, 4, 4); // Small red dot in mini-map
            }
            
            t++; // Increment frame counter
            requestAnimationFrame(draw); // Loop animation
        }
        
        // Start animation
        draw();
    </script>
</body>
</html>