<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Night Sky Perceptions</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        #sky { display: block; }
    </style>
</head>
<body>
    <canvas id="sky"></canvas>
    <script>
        let c = document.getElementById('sky');
        let ctx = c.getContext('2d');
        c.width = window.innerWidth;
        c.height = window.innerHeight;

        // Stars: barely perceptible movement
        let objects = [];
        for (let i = 0; i < 50; i++) {
            objects.push({
                x: Math.random() * c.width,
                y: Math.random() * c.height,
                speed: 0.01, // ~0.6px/sec, noticeable after 3-5 min
                color: 'white'
            });
        }

        // Two planes with realistic banking
        let planes = [
            { z: 100, size: 3, color: 'red', speedZ: 0.4, zigzagFreq: 0.02, active: true, trail: [] },
            { z: 120, size: 3, color: 'yellow', speedZ: 0.35, zigzagFreq: 0.025, active: true, trail: [] }
        ];
        let t = 0;

        function draw() {
            // Clear canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, c.width, c.height);

            // Draw stars
            for (let o of objects) {
                ctx.fillStyle = o.color;
                ctx.fillRect(o.x, o.y, 1, 1);
                o.x += o.speed;
                if (o.x > c.width) o.x = 0;
            }

            // Draw planes
            for (let plane of planes) {
                if (plane.active) {
                    // Approach: decrease z, increase size
                    if (t < 200) {
                        plane.z -= plane.speedZ;
                        plane.size = 3 + (100 - plane.z) * 0.1;
                    }
                    let px = c.width / 2 + Math.sin(t * plane.zigzagFreq) * 200;
                    let py = c.height / 2 - t * 0.5;
                    if (t > 200) {
                        px += (t - 200) * 3; // Bank right
                        py += Math.sin((t - 200) * 0.05) * 50; // Curved banking
                    }
                    if (px < c.width && py > 0 && plane.z > 0) {
                        ctx.fillStyle = plane.color;
                        // Draw triangle instead of square
                        ctx.beginPath();
                        ctx.moveTo(px, py - plane.size); // Top
                        ctx.lineTo(px - plane.size, py + plane.size); // Bottom-left
                        ctx.lineTo(px + plane.size, py + plane.size); // Bottom-right
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        plane.active = false;
                    }
                    // Store position for mini-map and trail
                    plane.px = px;
                    plane.py = py;
                    plane.trail.push({ x: px, y: py, z: plane.z });
                    if (plane.trail.length > 20) plane.trail.shift(); // Keep trail short
                }
            }

            // Mini-map
            let miniSize = 150;
            let miniX = c.width - miniSize - 20;
            let miniY = c.height - miniSize - 20;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(miniX, miniY, miniSize, miniSize);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(miniX, miniY, miniSize, miniSize);
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('N', miniX + miniSize / 2 - 5, miniY + 15);
            ctx.fillText('S', miniX + miniSize / 2 - 5, miniY + miniSize - 5);
            ctx.fillText('W', miniX + 5, miniY + miniSize / 2 + 5);
            ctx.fillText('E', miniX + miniSize - 15, miniY + miniSize / 2 + 5);
            ctx.beginPath();
            ctx.moveTo(miniX + miniSize / 2, miniY);
            ctx.lineTo(miniX + miniSize / 2, miniY + miniSize);
            ctx.moveTo(miniX, miniY + miniSize / 2);
            ctx.lineTo(miniX + miniSize, miniY + miniSize / 2);
            ctx.stroke();

            // Plot planes and trails in mini-map
            for (let plane of planes) {
                if (plane.active && plane.z > 0) {
                    // Draw trail
                    for (let i = 0; i < plane.trail.length; i++) {
                        let trailPt = plane.trail[i];
                        let trailX = miniSize / 2 + (trailPt.x - c.width / 2) / 10;
                        let trailY = miniSize / 2 - (trailPt.y - c.height / 2) / 10 + trailPt.z / 10;
                        ctx.fillStyle = plane.color;
                        ctx.globalAlpha = 0.3 * (i / plane.trail.length);
                        ctx.fillRect(miniX + trailX - 1, miniY + trailY - 1, 2, 2);
                    }
                    ctx.globalAlpha = 1.0;
                    // Draw current position
                    let mapX = miniSize / 2 + (plane.px - c.width / 2) / 10;
                    let mapY = miniSize / 2 - (plane.py - c.height / 2) / 10 + plane.z / 10;
                    ctx.fillStyle = plane.color;
                    ctx.fillRect(miniX + mapX - 2, miniY + mapY - 2, 4, 4);
                    // Speed label
                    let speed = (100 - plane.z) / 2;
                    ctx.fillStyle = 'white';
                    ctx.fillText(`${plane.color}: ${speed.toFixed(1)}`, miniX + 10, miniY + 30 + planes.indexOf(plane) * 15);
                }
            }

            t++;
            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>